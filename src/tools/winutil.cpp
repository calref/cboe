#include "winutil.hpp"

#include <boost/filesystem/operations.hpp>
#include "keymods.hpp"

// Measured on 5/23/25. For now, must be re-measured at 1x UI scale whenever preferences change (unless making the window smaller, maybe).
short prefs_height = 529;

// The default scale should be the largest that the user's screen can fit all three
// BoE application windows and core dialogs of the main game (because they should probably default to match each other).
double fallback_scale() {
	static double scale = 0;
	// Suppress the float comparison warning.
	// We know it's safe here - we're just comparing static values.
	#ifdef __GNUC__
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wfloat-equal"
	#endif
	if(scale == 0){
		sf::VideoMode desktop = sf::VideoMode::getDesktopMode();

		short max_width = max(boe_width, max(pc_width, scen_width));
		short max_height = max(prefs_height, max(boe_height, max(pc_height, scen_height))) + getMenubarHeight();

		std::vector<double> scale_options = {1.0, 1.5, 2.0, 3.0, 4.0};
		for(auto it = scale_options.rbegin(); it != scale_options.rend(); ++it){
			short max_scaled_width = max_width * (*it);
			short max_scaled_height = max_height * (*it);

			if(max_scaled_width <= desktop.width && max_scaled_height <= desktop.height){
				scale = (*it);
				break;
			}
		}
	}
	// Hopefully no one would ever have such a small monitor to not fit the default size.
	// But just in case:
	if(scale == 0){
		scale = 1.0;
	}
	#ifdef __GNUC__
	#pragma GCC diagnostic pop
	#endif

	return scale;
}

// We use many nested event loops in this codebase. Each one of them
// calls pollEvent() and they each need to remember to call handleModifier()
// or else modifier keys will claim to be held forever.
// The best solution for this is to wrap pollEvent() so that it calls
// handleModifier for us every time.
bool pollEvent(sf::Window& win, sf::Event& event){
    if(win.pollEvent(event)) {
        if(kb.handleModifier(event)) return false;
        return true;
    }

    return false;
}

bool pollEvent(sf::Window* win, sf::Event& event){
    return pollEvent(*win, event);
}

extern fs::path progDir;

void launchDocs(std::string relative_url) {
	if(fs::is_directory(progDir/"doc")){
		launchURL("file://" + (progDir/"doc"/relative_url).string());
	}else{
		launchURL("http://openboe.com/docs/" + relative_url);
	}
}

bool check_window_moved(sf::RenderWindow& win, int& winLastX, int& winLastY, std::string position_pref) {
	auto winPosition = win.getPosition();
	bool moved = false;
	if(winLastX != winPosition.x || winLastY != winPosition.y){
		// Save the positions of main window and map window as hidden preferences
		// (clamped to keep them fully on-screen when they appear the first time)
		if(!position_pref.empty()){
			sf::VideoMode desktop = sf::VideoMode::getDesktopMode();

			int pref_x = minmax(0, desktop.width - win.getSize().x, winPosition.x);
			int pref_y = minmax(0, desktop.height - win.getSize().y, winPosition.y);
			set_pref(position_pref + "X", pref_x);
			set_pref(position_pref + "Y", pref_y);
		}
		moved = true;
	}
	winLastX = winPosition.x;
	winLastY = winPosition.y;
	return moved;
}

void makeFrontWindow(sf::Window& win) {
	static sf::Event evt;
	_makeFrontWindow(win);
	// Discard GainedFocus events generated by our own meddling:
	while(pollEvent(win, evt));
}

void makeFrontWindow(sf::Window& win, sf::Window& prev) {
	static sf::Event evt;
	_makeFrontWindow(win);
	// Discard GainedFocus and LostFocus events generated by our own meddling:
	while(pollEvent(win, evt));
	while(pollEvent(prev, evt));
}

void setWindowFloating(sf::Window& win, bool floating) {
	static sf::Event evt;
	_setWindowFloating(win, floating);
	// Discard GainedFocus and LostFocus events generated by our own meddling:
	while(pollEvent(win, evt));
}
